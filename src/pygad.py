import gym
import minihack
import numpy as np
from typing import List
import random
import math
import pygad

#global GOAL_1, GOAL_2

movement_dictionary = {
    0 : "north",
    1 : "east",
    2 : "south",
    3 : "west",
}

class Rule:
    '''
    The class Rule generates a couple (position, movement)
    Each rule represents an individual (state) of the population of our genetic algorithm
    '''

    
    #The position of the agent in the 15x15 room (an np.ndarray)
    position: List[int] = [0, 0]

    movement: int
    # movement: {'north': 0, 'east': 1, 'south': 2, 'west': 3} 

    def __init__(self):
        '''
        Initiliaze a random position and random movement
        index_matrix represent the start position of the 15x15 room when is represented by a 21x79 matrix 
        '''

        self.position[0] = random.choice(range(0, 15))
        self.position[1] = random.choice(range(0, 15))
        

        #Move randomly in any direction
        self.movement = random.choice(range(0, 4))
        
        #check that the rule is well defined
        before_pos_1=self.position[0]
        before_pos_2=self.position[1]
        if self.movement==0 : 
             before_pos_1=before_pos_1-1 #movement to norh
        elif self.movement==1 :
             before_pos_2=before_pos_2+1 #movement to east
        elif self.movement==2 :
             before_pos_1=before_pos_1+1 #movement to sud
        elif self.movement==3:
             before_pos_2=before_pos_2-1 #movement to west
        
        while before_pos_1<0 or before_pos_1>=15 or before_pos_2<0 or before_pos_2>=15:
             print("RIP")
             self.movement = random.choice(range(0, 4))
             before_pos_1=self.position[0]
             before_pos_2=self.position[1]
             if self.movement==0 : 
                 before_pos_1=before_pos_1-1 #movement to norh
             elif self.movement==1 :
                 before_pos_2=before_pos_2+1 #movement to east
             elif self.movement==2 :
                 before_pos_1=before_pos_1+1 #movement to sud
             elif self.movement==3:
                 before_pos_2=before_pos_2-1 #movement to west

        
    def rule_list(self):
        return [self.position[0], self.position[1], self.movement]

def print_room(environment):
    """
    Print the room in ASCII characters. 
    Note that the matrix is equal to the random room generated by MiniHack
    """

    for row in range(len(environment[:,1])):
        for col in range(len(environment[1,:])):
            print(chr(environment[row][col]), end=' ') 
        print('\n')

def search_environment_indexes(environment):
    """ 
    Searching enviroment indexes, usually are the same, 
    maybe we can calculate theme once and them use as a costant
    if change for each different room maybe this will be useful then
    """
    
    i=j=temp=0

    #Find the indexes [x,y] from which to start extracting the submatrix
    for row in range(len(environment[:,1])):
        for col in range(len(environment[1,:])):
            if temp == 0 and int(environment[row][col]) != 32:
                i = row
                j = col
                temp=1
    return i,j      

def search_environment_agent_position(environment: np.ndarray):
    """ Return agent position inside the environment """
    
    for row in range(len(environment[:,1])):
        for col in range(len(environment[1,:])):
            if int(environment[row][col]) == 64:
                return row, col

def search_environment_goal_position(environment: np.ndarray):
    """ Return staircase position inside the environment """
    
    for row in range(len(environment[:,1])):
        for col in range(len(environment[1,:])):
            if int(environment[row][col]) == 62:
                global GOAL_1, GOAL_2
                GOAL_1=row
                GOAL_2=col
                return row, col


def fitness_function(solution, solution_idx):
     '''
     fitness function for the importance of every rules
     solution is a triple of int in which:
     solution[0]=first agent position in a rule
     solution[1]=second agent position in a rule
     solution[2]=agent action 
     '''
     
     ag_pos_before_rule_1=solution[0]
     ag_pos_before_rule_2=solution[1]

     #check that the generated rule is not the goal position
     if ag_pos_before_rule_1==GOAL_1 and ag_pos_before_rule_2==GOAL_2:
        return 0
     
     #define the new agent position after applying the action in solution[2]
     ag_pos_after_rule_1=solution[0] 
     ag_pos_after_rule_2=solution[1] 

     if solution[2]==0 : 
         ag_pos_after_rule_1=ag_pos_after_rule_1-1 #movement to norh
     elif solution[2]==1 :
         ag_pos_after_rule_2=ag_pos_after_rule_2+1 #movement to east
     elif solution[2]==2 :
         ag_pos_after_rule_1=ag_pos_after_rule_1+1 #movement to sud
     elif solution[2]==3:
         ag_pos_after_rule_2=ag_pos_after_rule_2-1 #movement to west
    

     #print(GOAL_1, "e ", GOAL_2)
     #print(ag_pos_before_rule_1, " e ", ag_pos_before_rule_2, "e ", solution[2])
     #print(ag_pos_after_rule_1, "e ",  ag_pos_after_rule_2)

     distance_before=np.abs(ag_pos_before_rule_1-GOAL_1)+np.abs(ag_pos_before_rule_2-GOAL_2)
     distance_after=np.abs(ag_pos_after_rule_1-GOAL_1)+np.abs(ag_pos_after_rule_2-GOAL_2)

     #print(distance_before, "e ", distance_after, ": ", distance_before-distance_after)
     
     auxiliar=(distance_before-distance_after)/(math.sqrt(distance_before))
     fitness=50*auxiliar+50
     #print(fitness)

     return fitness

def genetic_alg(list_of_rules, fitness_func):

    ga_instance=pygad.GA(fitness_func=fitness_func,
                         initial_population=list_of_rules
                         gene_type=List[int]
                         num_generations=100
                         num_parents_mating=2
                          )

def main():
    #Generate a Room-15x15 task
    env=gym.make(
        "MiniHack-Room-Random-15x15-v0",
        observation_keys=("chars", "colors", "specials", "pixel"),
)

    obs = env.reset() #Generate a new environment and save the describtions arrays in obs
    env.render() #Print the room 
    #
    #obs contains the "glyphs","chars",...,"pixel" arrays which describe the room
    #See documentation for information on arrays
    i,j = search_environment_indexes(obs['chars'])

    #print(i, " ", j)
    print("Tha matrix in ASCII that represent the random room is:")
    print_room(obs['chars'][i:i+15, j:j+15])
    
    
    agent_position_1, agent_position_2 = search_environment_agent_position(obs['chars'][i:i+15, j:j+15])
    goal_1, goal_2 = search_environment_goal_position(obs['chars'][i:i+15, j:j+15])
    
    print("The goal position is: ", goal_1, " ", goal_2)
    print("The agent position is: ", agent_position_1, " ",  agent_position_2)
    
    list_of_rules=[]
    for x in range(100):
        rule=Rule()
        list_of_rules.append(rule.rule_list())
        print("The", x+1, "-th rules is:")
        print("Position: (", list_of_rules[x][0], ", ", list_of_rules[x][1], ")")
        print("Movement: ", list_of_rules[x][2], " - ", movement_dictionary[list_of_rules[x][2]])
        
        """
        Define list_of_rules as a list of lists, in which every element of the main list is
        defined as triple of int [x_1, x_2, x_3] that are associated a one object, and in 
        particular we have:
        -x_1 is the agent_position_1
        -x_2 is the agent_position_2
        -x_3 is the agent movement
        
        We can not define list_of_rules as a list of object because of definitio of pygad library 
        """
    #fit=fitness_function(list_of_rules[0], 2)
    fitness_func = fitness_function
    fitness_value, population=genetic_alg(list_of_rules, fitness_func)


if __name__ == "__main__":
    main()
